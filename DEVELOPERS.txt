.. --*-- rest --*--
.. NB! Keep this document a valid restructured document.

Developing Scipy
================

:Author: Pearu Peterson <pearu@cens.ioc.ee>
:Last changed: $Date$
:Revision: $Revision$
:Discussions to: scipy-dev@scipy.org

.. Contents::

Introduction
------------

Scipy aims at being a robust and efficient "super-package" of a number
of its modules, each having a complexity and size to be a highly
non-trivial package itself. In order to "Scipy integration" to work
flawlessly, all Scipy modules must follow certain rules that are
described in this document. Hopefully this document will be helpful to
Scipy contributors as well as to developers as a basic reference about
the structure of Scipy package.

Scipy structure
---------------

Currently Scipy consists of the following files and directories:

  INSTALL.txt
    Scipy prerequisites, installation, testing, and troubleshooting.

  PACKAGERS.txt
    Information on how to package Scipy and related tools.

  THANKS.txt
    Scipy developers and contributors. Please keep it up to date!!

  DEVELOPERS.txt
    Scipy structure (this document).

  setup.py
    Script for building and installing Scipy.

  MANIFEST.in
    Additions to distutils generated Scipy tar-balls [Each Scipy
    module may contain its own MANIFEST.in and the main setup.py
    should merge them into MANIFEST.in].

  scipy_core/
    Contains three modules, scipy_base, scipy_distutils, and scipy_test,
    that all Scipy modules may depend on. As a rule, scipy_distutils
    is required only for building, scipy_test for running tests,
    and scipy_base contains various tools for runtime usage.

  Lib/
    Contains Scipy __init__.py and the directories of Scipy modules.

  Lib_chaco/
    Contains packages related to Chaco. [Can we move these packages
    under Lib/? No need, new hooks in setup.py takes care of this; in
    fact, we can introduce also contrib/ directory]

  tutorial/
    Scipy tutorial.

  util/
    Various tools [Not useful in general. Could we get rid of this?].


Scipy module
------------

In the following, a *Scipy module* is defined as a Python package, say
xxx, that is located in the Lib/ directory.  All Scipy modules should
follow the following conventions:

* Ideally, each Scipy module should be self-contained as much as
  possible, that is, it must be usable as standalone and have minimal
  dependencies to other packagers or modules, even if they would be
  also Scipy modules. The exception is ``scipy_base`` that is encouraged
  to be used as a replacement of ``Numeric`` or ``numarray`` modules
  to simplify the future transition Numeric->Numarray.

* Directory ``xxx/`` must contain 

  + a file ``setup_xxx.py`` that defines
    ``configuration(parent_package='')`` function.  See below for more
    details.

  + a file ``info_xxx.py``. See below more details.

* Directory ``xxx/`` may contain 

  + a directory ``tests/`` that contains files ``test_<name>.py``
    corresponding to modules ``xxx/<name>{.py,.so,/}``.  See below for
    more details.

  + a file ``MANIFEST.in``.

[Open issues: where we should put documentation?]

File xxx/setup_xxx.py
---------------------

Each Scipy module setup_xxx.py file should contain a function
``configuration(..)`` that returns a dictionary which must be usable
as an argument to distutils setup function.

For example, a minimal setup_xxx.py file for a pure Python Scipy
module xxx is::

  def configuration(parent_package=''):
      package = 'xxx'
      from scipy_distutils.misc_util import default_config_dict
      config = default_config_dict(package,parent_package)
      return config

  if __name__ == '__main__':
      from scipy_distutils.core import setup
      setup(**configuration())

File xxx/__init__.py
---------------------

To speed up the import time as well as to minimize memory usage, scipy
uses ppimport hooks to transparently postpone importing large modules
that might not be used during a Scipy usage session. But in order to
have an access to documentation of all Scipy modules, including of the
postponed modules, the documentation string of a module (that would
usually reside in __init__.py file) should be copied also 
to info_xxx.py file.

So, the contents of a typical xxx/__init__.py file would be::

  #
  # Module xxx - ...
  #

  from info_xxx import __doc__
  ...


File xxx/info_xxx.py
--------------------

Scipy setup.py and Lib/__init__.py files assume that each Scipy module
contains a info_xxx.py file. The following information will be looked
from this file:

__doc__
  The documentation string of the module.

__doc_title__
  The title of the module. If not defined then the first non-empty 
  line of __doc__ will be used.

standalone
  Boolean variable indicating whether the module should be installed
  as standalone or under scipy. Default value is False.

dependencies
  [Support not implemented yet, may be it is YAGNI]
  List of module names that the module depends on. The module will not
  be installed if any of the dependencies is missing. If the module
  depends on another Scipy module, say yyy, and that is not going to
  be installed standalone, then use full name, that is, ``scipy.yyy``
  instead of ``yyy``.

global_symbols
  List of names that should be imported to scipy name space.

ignore
  Boolean variable indicating that the module should be ignored or
  not. Default value is False. Useful when the module is platform
  dependent.

postpone_import
  Boolean variable indicating that importing module should be
  postponed until first attempt of its usage. Default value is False.

File xxx/tests/test_yyy.py
--------------------------

Ideally, each Python code, extension module, or a subpackage in ``xxx/``
directory should have the corresponding ``test_<name>.py`` file in
``xxx/tests/`` directory. This file should define classes derived
from ScipyTestCase class. Methods of such classes that names start
with ``bench_`` or ``check_`` or ``test_`` are passed on to unittest
machinery. These methods may have optional arguments, the default
value of the first argument defines the testing level number. Default
level is 1.

A minimal example of a ``test_yyy.py`` file that implements tests for
a module ``xxx.yyy`` containing a function ``zzz()``, is shown below::

  from scipy_test.testing import set_package_path, sys
  from scipy_test.testing import ScipyTestCase

  set_package_path()
  # make sure that all xxx symbols are imported before the del statement:
  from xxx.yyy import zzz
  del sys.path[0]

  class test_zzz(ScipyTestCase):
      def check_simple(self, level=1):
          assert zzz()=='Hello from zzz'
      #...

  if __name__ == "__main__":
      from scipy_test.testing import ScipyTest
      ScipyTest('xxx.yyy').run()

``ScipyTestCase`` is derived from ``unittest.TestCase`` and it
implements additional method ``measure(self, code_str, times=1)``.

``scipy_test.testing`` module provides also the following convenience
functions::

  assert_equal(ctual,desired,err_msg='',verbose=1)
  assert_almost_equal(actual,desired,decimal=7,err_msg='',verbose=1)
  assert_approx_equal(actual,desired,significant=7,err_msg='',verbose=1)
  assert_array_equal(x,y,err_msg='')
  assert_array_almost_equal(x,y,decimal=6,err_msg='')
  rand(*shape) # returns random array with a given shape

``ScipyTest`` managed running ``tests/test_*.py`` scripts. When using
its ``.run()`` method then the level and verbosity parameters for
tests are taken from ``sys.argv`` and the method
``.test(level,verbosity)`` is called.

