.. --*-- rest --*--
.. NB! Keep this document a valid restructured document.

Developing Scipy
================

:Author: Pearu Peterson <pearu@cens.ioc.ee>
:Last changed: $Date$
:Revision: $Revision$
:Discussions to: scipy-dev@scipy.org

.. Contents::

Introduction
------------

Scipy aims at being a robust and efficient "super-package" of a number
of its modules, each having a complexity and size to be a highly
non-trivial package itself. In order to "Scipy integration" to work
flawlessly, all Scipy modules must follow certain rules that are
described in this document. Hopefully this document will be helpful to
Scipy contributors as well as to developers as a basic reference about
the structure of Scipy package.

Scipy structure
---------------

Currently Scipy consists of the following files and directories:

  INSTALL.txt
    Scipy prerequisites, installation, testing, and troubleshooting.

  PACKAGERS.txt
    Information on how to package Scipy and related tools.

  THANKS.txt
    Scipy developers and contributors. Please keep it up to date!!

  DEVELOPERS.txt
    Scipy structure (this document).

  setup.py
    Script for building and installing Scipy.

  MANIFEST.in
    Additions to distutils generated Scipy tar-balls [Each Scipy
    module may contain its own MANIFEST.in and the main setup.py
    should merge them into MANIFEST.in].

  scipy_core/
    Contains three modules, scipy_base, scipy_distutils, and scipy_test,
    that all Scipy modules may depend on. As a rule, scipy_distutils
    is required only for building, scipy_test for running tests,
    and scipy_base contains various tools for runtime usage.

  Lib/
    Contains Scipy __init__.py and the directories of Scipy modules.

  Lib_chaco/
    Contains packages related to Chaco. [Can we move these packages
    under Lib/?]

  tutorial/
    Scipy tutorial.

  util/
    Various tools [Not useful in general. Could we get rid of this?].


Scipy module
------------

In the following, a *Scipy module* is defined as a Python package, say
xxx, that is located in the Lib/ directory.  All Scipy modules should
follow the following conventions:

* Ideally, each Scipy module should be self-contained as much as
  possible, that is, it must be usable as standalone and have minimal
  dependencies to other packagers or modules, even if they would be
  also Scipy modules. The exception is ``scipy_base`` that is encouraged
  to be used as a replacement of ``Numeric`` or ``numarray`` modules
  to simplify the future transition Numeric->Numarray.

* Directory ``xxx/`` must contain 

  + a file ``setup_xxx.py`` that defines
    ``configuration(parent_package='')`` function.  See ... for more
    details.

  + a file ``info_xxx.py``. See .. more details.

* Directory ``xxx/`` may contain 

  + a directory ``tests/`` that contains files ``test_<name>.py``
    corresponding to modules ``xxx/<name>{.py,.so,/}``.  See ... for
    more details.

  + a file ``MANIFEST.in``.

  + a file ``pre___init__.py`` that should contain the documentation
    string of the module, usually found in ``__init__.py`` file. See
    ... for more details.

[Open issues: where we should put documentation?]

File xxx/setup_xxx.py
---------------------

Each Scipy module setup_xxx.py file must contain a function
``configuration(..)`` that returns a dictionary which must be usable
as an argument to distutils setup function.

For example, a minimal setup_xxx.py file for a pure Python Scipy
module xxx is::

  def configuration(parent_package=''):
      package = 'xxx'
      from scipy_distutils.misc_util import default_config_dict
      config = default_config_dict(package,parent_package)
      return config

  if __name__ == '__main__':
      from scipy_distutils.core import setup
      setup(**configuration())



Files xxx/__init__.py and xxx/pre___init__.py
---------------------------------------------

To speed up the import time as well as to minimize memory usage, scipy
uses ppimport hooks to transparently postpone importing large modules
that might not be used during a Scipy usage session. But in order to
have an access to documentation of all Scipy modules, including of the
postponed modules, the documentation string of a module (that would
usually reside in __init__.py file) must be moved to pre___init__.py
file.

So, the contents of a typical xxx/__init__.py file is::

  #
  # Module xxx - ...
  #

  from pre___init__ import __doc__
  #from info_xxx import __doc__
  ...

[xxx/pre___init__.py functionality will be replaced with more general
hooks in xxx/info_xxx.py file]

File xxx/info_xxx.py
--------------------

[info_xxx.py functionality is not implemented in Scipy yet.]

Scipy setup.py and Lib/__init__.py files assume that each Scipy module
contains a info_xxx.py file. The following information will be looked
from this file:

__doc__
  The documentation string of the module.

__doc_title__
  The title of the module. If not defined then the first non-empty 
  line of __doc__ will be used.

standalone
  Boolean variable indicating whether the module should be installed
  as standalone or under scipy. Default value is False.

dependencies
  List of module names that the module depends on. The module will not
  be installed if any of the dependencies is missing. If the module
  depends on another Scipy module, say yyy, and that is not going to
  be installed standalone, then use full name, that is, ``scipy.yyy``
  instead of ``yyy``.

provides
  List of names that should be imported to scipy name space.

ignore
  Boolean variable indicating that the module should be ignored or
  not. Default value is False. Useful when the module is platform
  dependent.

File xxx/tests/test_yyy.py
--------------------------

Ideally, each Python code, extension module, or a subpackage in ``xxx/``
directory should have the corresponding ``test_<name>.py`` file in
``xxx/tests/`` directory. This file should define a function
``test_suite_list`` that must return a list of 2-tuples
``(<ScipyTestCase class>, <method name pattern>)``.

A minimal example of a ``test_yyy.py`` file that implements tests for
a module ``xxx.yyy`` containing a function ``zzz()``, is shown below::

  from scipy_test.testing import set_package_path, sys
  from scipy_test.testing import ScipyTestCase

  set_package_path()
  # make sure that all xxx symbols are imported before the del statement:
  from xxx.yyy import zzz
  del sys.path[0]

  class test_zzz(ScipyTestCase):
      def check_simple(self):
          assert zzz()=='Hello from zzz'
      #...

  # defining test_suite_list function is obligatory
  def test_suite_list(level=1):
      suite_list = []
      if level > 0:
          suite_list += [
              (test_zzz,'check_'),
	      #...
	      ]
      if level > 5:
          #...
      return suite_list

  if __name__ == "__main__":
      from scipy_test.testing import ScipyTest
      ScipyTest('xxx.yyy').test(level=1,verbosity=2)

``ScipyTestCase`` is derived from ``unittest.TestCase`` and it
implements additional method ``measure(self, code_str, times=1)``.

``scipy_test.testing`` module provides also the following convenience
functions::

  assert_equal(ctual,desired,err_msg='',verbose=1)
  assert_almost_equal(actual,desired,decimal=7,err_msg='',verbose=1)
  assert_approx_equal(actual,desired,significant=7,err_msg='',verbose=1)
  assert_array_equal(x,y,err_msg='')
  assert_array_almost_equal(x,y,decimal=6,err_msg='')
  rand(*shape) # returns random array with a given shape
