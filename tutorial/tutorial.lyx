#LyX 1.1 created this file. For more info see http://www.lyx.org/
\lyxformat 2.16
\textclass article
\language english
\inputencoding auto
\fontscheme default
\graphics default
\paperfontsize default
\spacing single 
\papersize Default
\paperpackage a4
\use_geometry 1
\use_amsmath 0
\paperorientation portrait
\leftmargin 1in
\topmargin 1in
\rightmargin 1in
\bottommargin 1in
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 1
\paperpagestyle default

\layout Section

Introduction
\layout Standard

SciPy is a collection of mathematical algorithms and convenience functions
 built on the Numeric extension for Python.
 It adds significant power to the interactive Python session by exposing
 the user to high-level commands and classes for the manipulation and visualizat
ion of data.
 With SciPy, an interactive Python session becomes a data-processing and
 system-prototyping environment rivaling sytems such as Matlab, IDL, Octave,
 R-Lab, and SciLab.
 
\layout Standard

The additional power of using SciPy within Python, however, is that a powerful
 programming language is also available for use in developing sophisticated
 programs and specialized applications.
 Scientific applications written in SciPy benefit from the development of
 additional modules in numerous niche's of the software landscape by developers
 across the world.
 Everything from parallel programming to web- and data-base subroutines
 and classes have been made available to the Python programmer.
 All of this power is available in addition to the more mathematical libraries
 in SciPy.
\layout Standard

This document provides a tutorial for the first-time user of SciPy to help
 get started with some of the features available in this powerful package.
 It is assumed that the user has already installed the package.
 Some general Python facility is also assumed such as could be acquired
 by working through the Tutorial in the Python distribution.
 
\layout Section

General help
\layout Standard

Python provides the facility of documentation strings.
 The functions and classes available in SciPy use this method for on-line
 documentation.
 There are two methods for reading these messages and getting help.
 Python provides the command help in the pydoc module.
 Entering this command with no arguments (i.e.
 >>> help ) launches an interactive help session that allows searching through
 the keywords and modules available to all of Python.
 Running the command help with an object as the argument displays the calling
 signature, and the documentation string of the object.
\layout Standard

The pydoc method of help is sophisticated but uses a pager to display the
 text.
 Sometimes this can interfere with the terminal you are running the interactive
 session within (like emacs).
 A scipy-specific help system is also available under the command scipy.help.
 The signature and documntation string for the object passed to the help
 command are printed to standard output (or to a writeable object passed
 as the third argument).
 The second keyword argument of 
\begin_inset Quotes eld
\end_inset 

scipy.help
\begin_inset Quotes erd
\end_inset 

 defines the maximum width of the line for printing.
\layout Standard

If a module is passed as the argument to help than a list of the functions
 and classes defined in that module is printed.
 
\layout Standard


\series bold 
Example:
\layout Standard


\begin_inset Include \verbatiminput{example2.1}

\end_inset 


\layout Section

Special Functions (scipy.special)
\layout Subsection

Vectorizing functions (scipy.special.general_function)
\layout Standard

One of the features that the 
\series bold 
special
\series default 
 sub-package provides is a class 
\series bold 
general_function
\series default 
 to convert an ordinary Python function which accepts scalars and returns
 scalars into a 
\begin_inset Quotes eld
\end_inset 

vectorized-function
\begin_inset Quotes erd
\end_inset 

 with the same broadcasting rules as other Numeric functions (
\emph on 
i.e.

\emph default 
 the Universal functions, or ufuncs).
 For example, suppose you have a Python function named 
\series bold 
addsubtract
\series default 
 defined as:
\layout Standard


\begin_inset Include \verbatiminput{example3.1}

\end_inset 

which defines a function of two scalar variables and returns a scalar result.
 The class general_function can be used to 
\begin_inset Quotes eld
\end_inset 

vectorize
\begin_inset Quotes erd
\end_inset 

 this function so that 
\latex latex 

\backslash 
begin{verbatim}
\newline 
>>> vec_addsubstract = scipy.special.general_function(addsubtract) 
\backslash 
end{verbatim} 
\newline 

\backslash 
noindent 
\latex default 
returns a function which takes array arguments and returns an array result:
\layout Standard


\begin_inset Include \verbatiminput{example3.2}

\end_inset 


\layout Subsection

Special Functions
\layout Standard

The main feature of the 
\series bold 
special
\series default 
 package is the definition of numerous special functions of mathematical
 physics.
 Available are airy, elliptic, bessel, gamma, beta, hypergeometric, and
 several statistical functions.
 All of these functions behave can take array arguments and return array
 results following the same broadcasting rules as other math functions in
 Numerical Python.
 For a complete list of these functions with a one-line description type
 
\family typewriter 
>>>help(scipy.special).
 
\family default 
Each function also has it's own documentation accessible using help.
\layout Section

Integration (scipy.integrate)
\layout Standard

The 
\series bold 
integrate
\series default 
 sub-package provides several integration techniques including an ordinary
 differential equation integrator.
 An overview of the module is provided by the help command:
\layout Standard


\begin_inset Include \verbatiminput{example4.1}

\end_inset 


\layout Subsection

General integration (scipy.integrate.quad)
\layout Standard

The function 
\series bold 
quad
\series default 
 is provided to integrate a function of one variable between two points.
 The points can be 
\begin_inset Formula \( \pm \infty  \)
\end_inset 

 (
\begin_inset Formula \( \pm  \)
\end_inset 

scipy.integrate.Inf) to indicate infinite limits.
 For example, suppose you wish to integrate a bessel function 
\family typewriter 
jv(2.5,x)
\family default 
 along the interval 
\begin_inset Formula \( [0,4.5]. \)
\end_inset 

 
\begin_inset Formula \[
I=\int _{0}^{4.5}J_{2.5}\left( x\right) \, dx.\]

\end_inset 

 This could be computed using 
\series bold 
quad:
\layout Standard


\begin_inset Include \verbatiminput{example4.2}

\end_inset 


\layout Standard

The first argument to quad is a 
\begin_inset Quotes eld
\end_inset 

callable
\begin_inset Quotes erd
\end_inset 

 Python object (
\emph on 
i.e 
\emph default 
a function, method, or class instance).
 Notice the use of a lambda-function in this case as the argument.
 The next two arguments are the limits of integration.
 The return value is a tuple, with the first element holding the estimated
 value of the integral and the second element holding an upper bound on
 the error.
 Notice, that in this case, the true value of this integral is 
\begin_inset Formula \[
I=\sqrt{\frac{2}{\pi }}\left( \frac{18}{27}\sqrt{2}\cos \left( 4.5\right) -\frac{4}{27}\sqrt{2}\sin \left( 4.5\right) +\sqrt{2\pi }\textrm{Si}\left( \frac{3}{\sqrt{\pi }}\right) \right) ,\]

\end_inset 

 where 
\begin_inset Formula \[
\textrm{Si}\left( x\right) =\int _{0}^{x}\sin \left( \frac{\pi }{2}t^{2}\right) \, dt.\]

\end_inset 

 is the Fresnel sine integral.
 Note that the numerically-computed integral is within 
\begin_inset Formula \( 1.04\times 10^{-11} \)
\end_inset 

 of the exact result --- well below the reported error bound.
 
\layout Standard

Infinite inputs are also allowed in 
\series bold 
quad
\series default 
 by using 
\begin_inset Formula \( \pm  \)
\end_inset 


\series bold 
scipy.integrate.Inf
\series default 
 as one of the arguments.
 For example, suppose that a numerical value for the exponential integral:
\begin_inset Formula \[
E_{n}\left( x\right) =\int _{1}^{\infty }\frac{e^{-xt}}{t^{n}}\, dt.\]

\end_inset 

 is desired (and the fact that this integral can be computed as 
\family typewriter 
scipy.special.expn(n,x)
\family default 
 is forgotten).
 The functionality of the function 
\series bold 
scipy.special.expn
\series default 
 can be replicated by defining a new function 
\series bold 
vec_expint 
\series default 
based on the routine 
\series bold 
quad: 
\layout Standard


\begin_inset Include \verbatiminput{example4.3}

\end_inset 

 
\layout Standard

The function which is integrated can even use the quad argument (though
 the error bound may underestimate the error due to possible numerical error
 in the integrand from the use of 
\series bold 
quad
\series default 
).
 The integral in this case is 
\begin_inset Formula \[
I_{n}=\int _{0}^{\infty }\int _{1}^{\infty }\frac{e^{-xt}}{t^{n}}\, dt\, dx=\frac{1}{n}.\]

\end_inset 


\layout Standard


\begin_inset Include \verbatiminput{example4.4}

\end_inset 


\layout Standard

This last example shows that multiple integration can be handled using repeated
 calls to
\series bold 
 quad.
 
\series default 
The mechanics of this for double and triple integration have been wrapped
 up into the functions 
\series bold 
dblquad 
\series default 
and 
\series bold 
tplquad.
 
\series default 
The function, 
\series bold 
dblquad 
\series default 
performs double integration.
 Use the help function to be sure that the arguments are defined in the
 correct order.
 In addition, the limits on all inner integrals are actually functions which
 can be constant functions.
 An example of using double integration to compute several values of 
\begin_inset Formula \( I_{n} \)
\end_inset 

 is shown below:
\layout Standard


\begin_inset Include \verbatiminput{example4.5}

\end_inset 


\layout Subsection

Ordinary differential equations (scipy.integrate.odeint)
\layout Standard

Integrating a set of ordinary differential equations (ODEs) given initial
 conditions is another useful example.
 The function 
\series bold 
odeint 
\series default 
is available in SciPy for integrating a first-order vector differential
 equation:
\begin_inset Formula \[
\frac{d\mathbf{y}}{dt}=\mathbf{f}\left( \mathbf{y},t\right) ,\]

\end_inset 

 given initial conditions 
\begin_inset Formula \( \mathbf{y}\left( 0\right) =y_{0}, \)
\end_inset 

 where 
\begin_inset Formula \( \mathbf{y} \)
\end_inset 

 is a length 
\begin_inset Formula \( N \)
\end_inset 

 vector and 
\begin_inset Formula \( \mathbf{f} \)
\end_inset 

 is a mapping from 
\begin_inset Formula \( {\cal R}^{N} \)
\end_inset 

 to 
\begin_inset Formula \( {\cal R}^{N}. \)
\end_inset 

 A higher-order ordinary differential equation can always be reduced to
 a differential equation of this type by introducing intermediate derivatives
 into the 
\begin_inset Formula \( \mathbf{y} \)
\end_inset 

 vector.
 
\layout Standard

For example suppose it is desired to find the solution to the following
 second-order differential equation:
\begin_inset Formula \[
\frac{d^{2}w}{dz^{2}}-zw(z)=0\]

\end_inset 

 with initial conditions 
\begin_inset Formula \( w\left( 0\right) =\frac{1}{\sqrt[3]{3^{2}}\Gamma \left( \frac{2}{3}\right) } \)
\end_inset 

 and 
\begin_inset Formula \( \left. \frac{dw}{dz}\right| _{z=0}=-\frac{1}{\sqrt[3]{3}\Gamma \left( \frac{1}{3}\right) }. \)
\end_inset 

 It is known that the solution to this differential equation is the Airy
 function 
\begin_inset Formula \[
w=\textrm{Ai}\left( z\right) ,\]

\end_inset 

 which gives a means to check the integrator using 
\series bold 
scipy.special.airy.
 
\layout Standard

First, convert this ODE into standard form by setting 
\begin_inset Formula \( \mathbf{y}=\left[ \frac{dw}{dz},w\right]  \)
\end_inset 

 and 
\begin_inset Formula \( t=z. \)
\end_inset 

 Thus, the differential equation becomes
\begin_inset Formula \[
\frac{d\mathbf{y}}{dt}=\left[ \begin{array}{c}
ty_{1}\\
y_{0}
\end{array}\right] =\left[ \begin{array}{cc}
0 & t\\
1 & 0
\end{array}\right] \left[ \begin{array}{c}
y_{0}\\
y_{1}
\end{array}\right] =\left[ \begin{array}{cc}
0 & t\\
1 & 0
\end{array}\right] \mathbf{y}.\]

\end_inset 

 In other words, 
\begin_inset Formula \[
\mathbf{f}\left( \mathbf{y},t\right) =\mathbf{A}\left( t\right) \mathbf{y}.\]

\end_inset 

 
\layout Standard

As an interesting reminder, if 
\begin_inset Formula \( \mathbf{A}\left( t\right)  \)
\end_inset 

 commutes with 
\begin_inset Formula \( \int _{0}^{t}\mathbf{A}\left( \tau \right) \, d\tau  \)
\end_inset 

 under matrix multiplication, then this linear differential equation has
 exact solution using the matrix exponential: 
\begin_inset Formula \[
\mathbf{y}\left( t\right) =\exp \left( \int _{0}^{t}\mathbf{A}\left( \tau \right) d\tau \right) \mathbf{y}\left( 0\right) ,\]

\end_inset 

 However, in this case, 
\begin_inset Formula \( \mathbf{A}\left( t\right)  \)
\end_inset 

 and its integral do not commute.
\layout Standard

There are many optional inputs and outputs available when using odeint which
 can help tune the solver.
 These additional inputs and outputs are not needed much of the time, however,
 and the three required input arguments and the output solution suffice.
 The required inputs are the function defining the derivative, the initial
 output vector, and the time points to obtain a solution (with the initial
 value point as the first element of this sequence).
 The output to 
\series bold 
odeint
\series default 
 is a matrix where each row contains the solution vector at each requested
 time point (thus, the initial conditions are given in the first output
 row).
 
\layout Standard

The following example illustrates the use of odeint including the usage
 of the 
\series bold 
Dfun
\series default 
 option which allows the user to specify a gradient (with respect to 
\begin_inset Formula \( \mathbf{y} \)
\end_inset 

) of the function, 
\series bold 

\begin_inset Formula \( \mathbf{f}\left( \mathbf{y},t\right)  \)
\end_inset 

.
\layout Standard


\begin_inset Include \verbatiminput{example4.6}

\end_inset 


\layout Subsection

Gaussian quadrature (scipy.integrate.gauss_quadtol)
\layout Standard

A few functions are also provided in order to perform simple Gaussian quadrature
 over a fixed interval.
 The first is 
\series bold 
gauss_quad 
\series default 
which performs fixed-order Gaussian quadrature.
 The second function is 
\series bold 
gauss_quadtol 
\series default 
which performs Gaussian quadrature of multiple orders until the difference
 in the integral estimate is beneath some tolerance supplied by the user.
 These functions both use the module 
\series bold 
scipy.integrate.orthogonal 
\series default 
which can calculate the roots and quadrature weights of a large variety
 of orthogonal polynomials.
\layout Section

Optimization (scipy.optimize)
\layout Standard

There are several classical optimization algorithms provided by SciPy in
 the 
\series bold 
scipy.optimize 
\series default 
package.
 An overview of the module is available using 
\series bold 
scipy.help 
\series default 
(or pydoc.help):
\layout Standard


\begin_inset Include \verbatiminput{example5.1}

\end_inset 

 The first four algorithms are unconstrained minimization algorithms (fmin:
 Nelder-Mead simplex, fmin_bfgs: BFGS, fmin_ncg: Newton Conjugate Gradient,
 and leastsq: Levenburg-Marquardt).
 The fourth algorithm only works for functions of a single variable but
 allows minimization over a specified interval.
 The last algorithm actually finds the roots of a general function of possibly
 many variables.
 It is included in the optimization package because at the (non-boundary)
 extreme points of a function, the gradient is equal to zero.
\layout Subsection

Nelder-Mead Simplex algorithm (scipy.optimize.fmin)
\layout Standard

The simplex algorithm is probably the simplest way to minimize a fairly
 well-behaved function.
 The simplex algorithm requires only function evaluations and is a good
 choice for simple minimization problems.
 However, because it does not use any gradient evaluations, it may take
 longer to find the minimum.
 To demonstrate the minimization function consider the problem of minimizing
 the Rosenbrock function of 
\begin_inset Formula \( N \)
\end_inset 

 variables:
\begin_inset Formula \[
f\left( \mathbf{x}\right) =\sum _{i=1}^{N-1}100\left( x_{i}-x_{i-1}^{2}\right) ^{2}+\left( 1-x_{i-1}\right) ^{2}.\]

\end_inset 

 The minimum value of this function is 0 which is achieved when 
\begin_inset Formula \( x_{i}=1. \)
\end_inset 

 This minimum can be found using the 
\series bold 
fmin
\series default 
 routine as shown in the example below:
\layout Standard


\begin_inset Include \verbatiminput{example5.2}

\end_inset 


\layout Subsection

Broyden-Fletcher-Goldfarb-Shanno algorithm (scipy.optimize.fmin_bfgs)
\layout Standard

In order to converge more quickly to the solution, this routine uses the
 gradient of the objective function.
 If the gradient is not given by the user, then it is estimated using first-diff
erences.
 The Broyden-Fletcher-Goldfarb-Shanno (BFGS) method requires fewer function
 calls than the simplex algorithm but unless the gradient is provided by
 the user, the speed savings won't be significant.
\layout Standard

To demonstrate this algorithm, the Rosenbrock function is again used.
 The gradient of the Rosenbrock function is the vector: 
\begin_inset Formula \begin{eqnarray*}
\frac{\partial f}{\partial x_{j}} & = & \sum _{i=1}^{N}200\left( x_{i}-x_{i-1}^{2}\right) \left( \delta _{i,j}-2x_{i-1}\delta _{i-1,j}\right) -2\left( 1-x_{i-1}\right) \delta _{i-1,j}.\\
 & = & 200\left( x_{j}-x^{2}_{j-1}\right) -400x_{j}\left( x_{j+1}-x_{j}^{2}\right) -2\left( 1-x_{j}\right) .
\end{eqnarray*}

\end_inset 

This expression is valid for the interior derivatives.
 Special cases are
\begin_inset Formula \begin{eqnarray*}
\frac{\partial f}{\partial x_{0}} & = & -400x_{0}\left( x_{1}-x_{0}^{2}\right) -2\left( 1-x_{0}\right) ,\\
\frac{\partial f}{\partial x_{N-1}} & = & 200\left( x_{N-1}-x_{N-2}^{2}\right) .
\end{eqnarray*}

\end_inset 

 A Python function which computes this gradient is constructed by the code-segme
nt:
\layout Standard


\begin_inset Include \verbatiminput{example5.3}

\end_inset 


\layout Standard

The calling signature for the BFGS minimization algorithm is similar to
 
\series bold 
fmin
\series default 
 with the addition of the 
\emph on 
fprime
\emph default 
 argument.
 An example usage of 
\series bold 
fmin_bfgs
\series default 
 is shown in the following example which minimizes the Rosenbrock function.
\layout Standard


\begin_inset Include \verbatiminput{example5.4}

\end_inset 


\layout Subsection

Newton-Conjugate-Gradient (scipy.optimize.fmin_ncg)
\layout Standard

The method which requires the fewest function calls and is therefore often
 the fastest method to minimize functions of many variables is 
\series bold 
fmin_ncg.
 
\series default 
This method is a modified Newton's method and uses a conjugate gradient
 algorithm to (approximately) invert the local Hessian.
 Newton's method is based on fitting the function locally to a quadratic
 form:
\begin_inset Formula \[
f\left( \mathbf{x}\right) \approx f\left( \mathbf{x}_{0}\right) +\nabla f\left( \mathbf{x}_{0}\right) \cdot \left( \mathbf{x}-\mathbf{x}_{0}\right) +\frac{1}{2}\left( \mathbf{x}-\mathbf{x}_{0}\right) ^{T}\mathbf{H}\left( \mathbf{x}_{0}\right) \left( \mathbf{x}-\mathbf{x}_{0}\right) .\]

\end_inset 

 where 
\begin_inset Formula \( \mathbf{H}\left( \mathbf{x}_{0}\right)  \)
\end_inset 

 is a matrix of second-derivatives (the Hessian).
 If the Hessian is positive definite then the local minimum of this function
 can be found by setting the gradient of the quadratic form to zero, resulting
 in 
\begin_inset Formula \[
\mathbf{x}_{\textrm{opt}}=\mathbf{x}_{0}-\mathbf{H}^{-1}\nabla f.\]

\end_inset 

 The inverse of the Hessian is evaluted using the conjugate-gradient method.
 An example of employing this method to minimizing the Rosenbrock function
 is given below.
 To take full advantage of the NewtonCG method, a function which computes
 the Hessian must be provided.
 The Hessian matrix itself does not need to be constructed, only a vector
 which is the product of the Hessian with an arbitrary vector needs to be
 available to the minimization routine.
 As a result, the user can provide either a function to compute the Hessian
 matrix, or a function to compute the product of the Hessian with an arbitrary
 vector.
 
\layout Subsubsection

Full Hessian example:
\layout Standard

The Hessian of the Rosenbrock function is 
\begin_inset Formula \begin{eqnarray*}
H_{ij}=\frac{\partial ^{2}f}{\partial x_{i}\partial x_{j}} & = & 200\left( \delta _{i,j}-2x_{i-1}\delta _{i-1,j}\right) -400x_{i}\left( \delta _{i+1,j}-2x_{i}\delta _{i,j}\right) -400\delta _{i,j}\left( x_{i+1}-x_{i}^{2}\right) +2\delta _{i,j},\\
 & = & \left( 202+1200x_{i}^{2}-400x_{i+1}\right) \delta _{i,j}-400x_{i}\delta _{i+1,j}-400x_{i-1}\delta _{i-1,j},
\end{eqnarray*}

\end_inset 

 if 
\begin_inset Formula \( i,j\in \left[ 1,N-2\right]  \)
\end_inset 

 with 
\begin_inset Formula \( i,j\in \left[ 0,N-1\right]  \)
\end_inset 

 defining the 
\begin_inset Formula \( N\times N \)
\end_inset 

 matrix.
 Other non-zero entries of the matrix are 
\begin_inset Formula \begin{eqnarray*}
\frac{\partial ^{2}f}{\partial x_{0}^{2}} & = & 1200x_{0}^{2}-400x_{1}+2,\\
\frac{\partial ^{2}f}{\partial x_{0}\partial x_{1}}=\frac{\partial ^{2}f}{\partial x_{1}\partial x_{0}} & = & -400x_{0},\\
\frac{\partial ^{2}f}{\partial x_{N-1}\partial x_{N-2}}=\frac{\partial ^{2}f}{\partial x_{N-2}\partial x_{N-1}} & = & -400x_{N-2},\\
\frac{\partial ^{2}f}{\partial x^{2}_{N-1}} & = & 200.
\end{eqnarray*}

\end_inset 

 For example, the Hessian when 
\begin_inset Formula \( N=5 \)
\end_inset 

 is 
\begin_inset Formula \[
\mathbf{H}=\left[ \begin{array}{ccccc}
1200x_{0}^{2}-400x_{1}+2 & -400x_{0} & 0 & 0 & 0\\
-400x_{0} & 202+1200x_{1}^{2}-400x_{2} & -400x_{1} & 0 & 0\\
0 & -400x_{1} & 202+1200x_{2}^{2}-400x_{3} & -400x_{2} & 0\\
0 &  & -400x_{2} & 202+1200x_{3}^{2}-400x_{4} & -400x_{3}\\
0 & 0 & 0 & -400x_{3} & 200
\end{array}\right] .\]

\end_inset 

 The code which computes this Hessian along with the code to minimize the
 function using 
\series bold 
fmin_ncg 
\series default 
is shown in the following example:
\layout Standard


\begin_inset Include \verbatiminput{example5.5}

\end_inset 


\layout Subsubsection

Hessian product example:
\layout Standard

For larger minimization problems, storing the entire Hessian matrix can
 consume considerable time and memory.
 The Newton-CG algorithm only needs the product of the Hessian times an
 arbitrary vector.
 As a result, the user can supply code to compute this product rather than
 the full Hessian by setting the 
\emph on 
fhess_p 
\emph default 
keyword to the desired function.
 The fhess_p function should take
\series bold 
 
\series default 
the minimization vector as the first argument and the arbitrary vector as
 the second argument.
 Any extra arguments passed to the function to be minimized will also be
 passed to this function.
 If possible, using Newton-CG with the hessian product option is probably
 the fastest way to minimize the function.
 
\layout Standard

In this case, the product of the Rosenbrock Hessian with an arbitrary vector
 is not difficult to compute.
 If 
\begin_inset Formula \( \mathbf{p} \)
\end_inset 

 is the arbitrary vector, then 
\begin_inset Formula \( \mathbf{H}\left( \mathbf{x}\right) \mathbf{p} \)
\end_inset 

 has elements: 
\begin_inset Formula \[
\mathbf{H}\left( \mathbf{x}\right) \mathbf{p}=\left[ \begin{array}{c}
\left( 1200x_{0}^{2}-400x_{1}+2\right) p_{0}-400x_{0}p_{1}\\
\vdots \\
-400x_{i-1}p_{i-1}+\left( 202+1200x_{i}^{2}-400x_{i+1}\right) p_{i}-400x_{i}p_{i+1}\\
\vdots \\
-400x_{N-2}p_{N-2}+200p_{N-1}
\end{array}\right] .\]

\end_inset 

 Code which makes use of the 
\emph on 
fhess_p 
\emph default 
keyword to minimize the Rosenbrock function using 
\series bold 
fmin_ncg
\series default 
 follows:
\layout Standard


\begin_inset Include \verbatiminput{example5.6}

\end_inset 


\layout Subsection

Least-square fitting (scipy.minimize.leastsq)
\layout Standard

All of the previously-explained minimization procedures can be used to solve
 a least-squares problem provided the appropriate objective function is
 constructed.
 For example, suppose it is desired to fit a set of data 
\begin_inset Formula \( \left\{ \mathbf{x}_{i},\mathbf{y}_{i}\right\}  \)
\end_inset 

 to a known model, 
\begin_inset Formula \( \mathbf{y}=\mathbf{f}\left( \mathbf{x},\mathbf{p}\right)  \)
\end_inset 

 where 
\begin_inset Formula \( \mathbf{p} \)
\end_inset 

 is a vector of parameters for the model that need to be found.
 A common method for determining which parameter vector gives the best fit
 to the data is to minimize the sum of squares of the residuals.
 The residual is usually defined for each observed data-point as 
\begin_inset Formula \[
e_{i}\left( \mathbf{p},\mathbf{y}_{i},\mathbf{x}_{i}\right) =\left\Vert \mathbf{y}_{i}-\mathbf{f}\left( \mathbf{x}_{i},\mathbf{p}\right) \right\Vert .\]

\end_inset 

 An objective function to pass to any of the previous minization algorithms
 to obtain a least-squares fit is.
 
\begin_inset Formula \[
J\left( \mathbf{p}\right) =\sum _{i=0}^{N-1}e_{i}^{2}\left( \mathbf{p}\right) .\]

\end_inset 

 
\layout Standard

The 
\series bold 
leastsq 
\series default 
algorithm performs this squaring and summing of the residuals automatically.
 It takes as an input argument the vector function 
\begin_inset Formula \( \mathbf{e}\left( \mathbf{p}\right)  \)
\end_inset 

 and returns the value of 
\begin_inset Formula \( \mathbf{p} \)
\end_inset 

 which minimizes 
\begin_inset Formula \( J\left( \mathbf{p}\right) =\mathbf{e}^{T}\mathbf{e} \)
\end_inset 

 directly.
 The user is also encouraged to provide the Jacobian matrix of the function
 (with derivatives down the columns or across the rows).
 If the Jacobian is not provided, it is estimated.
 
\layout Standard

An example should clarify the usage.
 Suppose it is believed some measured data follow a sinusoidal pattern
\begin_inset Formula \[
y_{i}=A\sin \left( 2\pi kx_{i}+\theta \right) \]

\end_inset 

 where the parameters 
\begin_inset Formula \( A, \)
\end_inset 

 
\begin_inset Formula \( k \)
\end_inset 

, and 
\begin_inset Formula \( \theta  \)
\end_inset 

 are unknown.
 The residual vector is 
\begin_inset Formula \[
e_{i}=\left| y_{i}-A\sin \left( 2\pi kx_{i}+\theta \right) \right| .\]

\end_inset 

 By defining a function to compute the residuals and (selecting an appropriate
 starting position), the least-squares fit routine can be used to find the
 best-fit parameters 
\begin_inset Formula \( \hat{A},\, \hat{k},\, \hat{\theta } \)
\end_inset 

.
 This is shown in the following example and a plot of the results is shown
 in Figure 
\begin_inset LatexCommand \ref{fig:least_squares_fit}

\end_inset 

.
\layout Standard


\begin_inset Include \verbatiminput{example5.7}

\end_inset 


\layout Standard

\begin_float fig 
\layout Standard
\align center 

\begin_inset Figure size 297 420
file leastsqfit.pdf
width 3 50.00
flags 11

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{fig:least_squares_fit}

\end_inset 

Least-square fitting to noisy data using 
\series bold 
scipy.optimize.leastsq
\end_float 
\layout Subsection

Bounded minimization (scipy.optimize.fminbound)
\layout Standard

Thus far all of the minimization routines described have been unconstrained
 minimization routines.
 Very often, however, there are constraints that can be placed on the solution
 space before minimization occurs.
 The 
\series bold 
fminbound 
\series default 
function is an example of a constrained minimization procedure that provides
 a rudimentary interval constraint for scalar functions (functions which
 take a scalar input and return a scalar output).
 The interval constraint allows the minimization to occur only between two
 fixed endpoints.
\layout Standard

For example, to find the minimum of 
\begin_inset Formula \( J_{1}\left( x\right)  \)
\end_inset 

 near 
\begin_inset Formula \( x=5 \)
\end_inset 

, 
\series bold 
fminbound 
\series default 
can be called using the interval 
\begin_inset Formula \( \left[ 4,7\right]  \)
\end_inset 

 as a constraint.
 The result is 
\begin_inset Formula \( x_{\textrm{min}}=5.3314 \)
\end_inset 

:
\layout Standard


\begin_inset Include \verbatiminput{example5.8}

\end_inset 


\layout Subsection

Root finding (scipy.optimize.fsolve)
\layout Standard

To find the roots of a polynomial, the command from Numeric Python: 
\series bold 
MLab.roots 
\series default 
is useful.
 To find a root of a set of non-linear equations, the command 
\series bold 
scipy.optimize.fsolve
\series default 
 is available.
 For example, the following example finds the roots of the single-variable
 transcendental equation
\begin_inset Formula \[
x+2\cos \left( x\right) =0,\]

\end_inset 

 and the set of non-linear equations
\begin_inset Formula \begin{eqnarray*}
x_{0}\cos \left( x_{1}\right)  & = & 4,\\
x_{0}x_{1}-x_{1} & = & 5.
\end{eqnarray*}

\end_inset 

 The results are 
\begin_inset Formula \( x=-1.0299 \)
\end_inset 

 and 
\begin_inset Formula \( x_{0}=6.5041,\, x_{1}=0.9084 \)
\end_inset 

.
\layout Standard


\begin_inset Include \verbatiminput{example5.9}

\end_inset 


\layout Section

Interpolation (scipy.interpolate)
\layout Standard

There are two general interpolation facilities available in SciPy.
 The first facility is an Interpolation class which performs linear 1-dimensiona
l interpolation.
 The second facility is based on the FORTRAN library FITPACK and provides
 functions for 1- and 2-dimensional (smoothed) cubic-spline interpolation.
 
\layout Subsection

Linear 1-d interpolation (interpolate.linear_1d)
\layout Standard

The linear_1d class in scipy.interpolate is a convenient method to create
 a function based on fixed data points which can be evaluated anywhere within
 the domain defined by the given data using linear interpolation.
 An instance of this class is instantiated by passing the 1-d vectors comprising
 the data.
 The instance of this class defines a 
\emph on 
__call__
\emph default 
 method and can therefore by treated like a function which interpolates
 between known data values to obtain unknown values (it even has a docstring
 for help).
 Behavior at the boundary can be specified at instantiation time.
 The following example demonstrates it's use.
 
\the_end
