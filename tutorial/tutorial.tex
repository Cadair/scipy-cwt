%% LyX 1.1 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[english]{article}
\usepackage[OT1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{geometry}
\geometry{verbose,letterpaper,tmargin=1in,bmargin=1in,lmargin=1in,rmargin=1in}
\usepackage{babel}
\usepackage{verbatim}

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
\providecommand{\LyX}{L\kern-.1667em\lower.25em\hbox{Y}\kern-.125emX\@}

\makeatother
\begin{document}

\section{Introduction}

SciPy is a collection of mathematical algorithms and convenience functions
built on the Numeric extension for Python. It adds significant power
to the interactive Python session by exposing the user to high-level
commands and classes for the manipulation and visualization of data.
With SciPy, an interactive Python session becomes a data-processing
and system-prototyping environment rivaling sytems such as Matlab,
IDL, Octave, R-Lab, and SciLab. 

The additional power of using SciPy within Python, however, is that
a powerful programming language is also available for use in developing
sophisticated programs and specialized applications. Scientific applications
written in SciPy benefit from the development of additional modules
in numerous niche's of the software landscape by developers across
the world. Everything from parallel programming to web- and data-base
subroutines and classes have been made available to the Python programmer.
All of this power is available in addition to the more mathematical
libraries in SciPy.

This document provides a tutorial for the first-time user of SciPy
to help get started with some of the features available in this powerful
package. It is assumed that the user has already installed the package.
Some general Python facility is also assumed such as could be acquired
by working through the Tutorial in the Python distribution. 


\section{General help}

Python provides the facility of documentation strings. The functions
and classes available in SciPy use this method for on-line documentation.
There are two methods for reading these messages and getting help.
Python provides the command help in the pydoc module. Entering this
command with no arguments (i.e. \textgreater{}\textgreater{}\textgreater{}
help ) launches an interactive help session that allows searching
through the keywords and modules available to all of Python. Running
the command help with an object as the argument displays the calling
signature, and the documentation string of the object.

The pydoc method of help is sophisticated but uses a pager to display
the text. Sometimes this can interfere with the terminal you are running
the interactive session within (like emacs). A scipy-specific help
system is also available under the command scipy.help. The signature
and documntation string for the object passed to the help command
are printed to standard output (or to a writeable object passed as
the third argument). The second keyword argument of {}``scipy.help{}''
defines the maximum width of the line for printing.

If a module is passed as the argument to help than a list of the functions
and classes defined in that module is printed. 

\textbf{Example:}

\verbatiminput{example2.1}


\section{Special Functions (scipy.special)}


\subsection{Vectorizing functions (scipy.special.GeneralFunction)}

One of the features that the \textbf{special} sub-package provides
is a class \textbf{GeneralFunction} to convert an ordinary Python
function which accepts scalars and returns scalars into a {}``vectorized-function{}''
with the same broadcasting rules as other Numeric functions (\emph{i.e.}
the Universal functions, or ufuncs). For example, suppose you have
a Python function named \textbf{addsubtract} defined as:

\verbatiminput{example3.1}which defines a function of two scalar
variables and returns a scalar result. The class GeneralFunction can
be used to {}``vectorize{}'' this function so that \begin{verbatim}
>>> vec_addsubstract = scipy.special.GeneralFunction(addsubtract) \end{verbatim} 
\noindent returns a function which takes array arguments and returns
an array result:

\verbatiminput{example3.2}


\subsection{Special Functions}

The main feature of the \textbf{special} package is the definition
of numerous special functions of mathematical physics. Available are
airy, elliptic, bessel, gamma, beta, hypergeometric, and several statistical
functions. All of these functions behave can take array arguments
and return array results following the same broadcasting rules as
other math functions in Numerical Python. For a complete list of these
functions with a one-line description type \texttt{>>>help(scipy.special).}
Each function also has it's own documentation accessible using help.


\section{Integration (scipy.integrate)}

The \textbf{integrate} sub-package provides several integration techniques
including an ordinary differential equation integrator. An overview
of the module is provided by the help command:

\verbatiminput{example4.1}


\subsection{General integration (scipy.integrate.quad)}

The function \textbf{quad} is provided to integrate a function of
one variable between two points. The points can be \( \pm \infty  \)
(\( \pm  \)scipy.integrate.Inf) to indicate infinite limits. For
example, suppose you wish to integrate a bessel function \texttt{jv(2.5,x)}
along the interval \( [0,4.5]. \) \[
I=\int _{0}^{4.5}J_{2.5}\left( x\right) \, dx.\]
 This could be computed using \textbf{quad:}

\verbatiminput{example4.2}

The first argument to quad is a {}``callable{}'' Python object (\emph{i.e}
a function, method, or class instance). Notice the use of a lambda-function
in this case as the argument. The next two arguments are the limits
of integration. The return value is a tuple, with the first element
holding the estimated value of the integral and the second element
holding an upper bound on the error. Notice, that in this case, the
true value of this integral is \[
I=\sqrt{\frac{2}{\pi }}\left( \frac{18}{27}\sqrt{2}\cos \left( 4.5\right) -\frac{4}{27}\sqrt{2}\sin \left( 4.5\right) +\sqrt{2\pi }\textrm{Si}\left( \frac{3}{\sqrt{\pi }}\right) \right) ,\]
 where \[
\textrm{Si}\left( x\right) =\int _{0}^{x}\sin \left( \frac{\pi }{2}t^{2}\right) \, dt.\]
 is the Fresnel sine integral. Note that the numerically-computed
integral is within \( 1.04\times 10^{-11} \) of the exact result
--- well below the reported error bound. 

Infinite inputs are also allowed in \textbf{quad} by using \( \pm  \)\textbf{scipy.integrate.Inf}
as one of the arguments. For example, suppose that a numerical value
for the exponential integral:\[
E_{n}\left( x\right) =\int _{1}^{\infty }\frac{e^{-xt}}{t^{n}}\, dt.\]
 is desired (and the fact that this integral can be computed as \texttt{scipy.special.expn(n,x)}
is forgotten). The functionality of the function \textbf{scipy.special.expn}
can be replicated by defining a new function \textbf{vec\_expint}
based on the routine \textbf{quad: }

\verbatiminput{example4.3} 

The function which is integrated can even use the quad argument (though
the error bound may underestimate the error due to possible numerical
error in the integrand from the use of \textbf{quad}). The integral
in this case is \[
I_{n}=\int _{0}^{\infty }\int _{1}^{\infty }\frac{e^{-xt}}{t^{n}}\, dt\, dx=\frac{1}{n}.\]


\verbatiminput{example4.4}

This last example shows that multiple integration can be handled using
repeated calls to \textbf{quad.} The mechanics of this for double
and triple integration have been wrapped up into the functions \textbf{dblquad}
and \textbf{tplquad.} The function, \textbf{dblquad} performs double
integration. Use the help function to be sure that the arguments are
defined in the correct order. In addition, the limits on all inner
integrals are actually functions which can be constant functions.
An example of using double integration to compute several values of
\( I_{n} \) is shown below:

\verbatiminput{example4.5}


\subsection{Ordinary differential equations (scipy.integrate.odeint)}

Integrating a set of ordinary differential equations (ODEs) given
initial conditions is another useful example. The function \textbf{odeint}
is available in SciPy for integrating a first-order vector differential
equation:\[
\frac{d\mathbf{y}}{dt}=\mathbf{f}\left( \mathbf{y},t\right) ,\]
 given initial conditions \( \mathbf{y}\left( 0\right) =y_{0}, \)
where \( \mathbf{y} \) is a length \( N \) vector and \( \mathbf{f} \)
is a mapping from \( {\cal R}^{N} \) to \( {\cal R}^{N}. \) A higher-order
ordinary differential equation can always be reduced to a differential
equation of this type by introducing intermediate derivatives into
the \( \mathbf{y} \) vector. 

For example suppose it is desired to find the solution to the following
second-order differential equation:\[
\frac{d^{2}w}{dz^{2}}-zw(z)=0\]
 with initial conditions \( w\left( 0\right) =\frac{1}{\sqrt[3]{3^{2}}\Gamma \left( \frac{2}{3}\right) } \)
and \( \left. \frac{dw}{dz}\right| _{z=0}=-\frac{1}{\sqrt[3]{3}\Gamma \left( \frac{1}{3}\right) }. \)
It is known that the solution to this differential equation is the
Airy function \[
w=\textrm{Ai}\left( z\right) ,\]
 which gives a means to check the integrator using \textbf{scipy.special.airy. }

First, convert this ODE into standard form by setting \( \mathbf{y}=\left[ \frac{dw}{dz},w\right]  \)
and \( t=z. \) Thus, the differential equation becomes\[
\frac{d\mathbf{y}}{dt}=\left[ \begin{array}{c}
ty_{1}\\
y_{0}
\end{array}\right] =\left[ \begin{array}{cc}
0 & t\\
1 & 0
\end{array}\right] \left[ \begin{array}{c}
y_{0}\\
y_{1}
\end{array}\right] =\left[ \begin{array}{cc}
0 & t\\
1 & 0
\end{array}\right] \mathbf{y}.\]
 In other words, \[
\mathbf{f}\left( \mathbf{y},t\right) =\mathbf{A}\left( t\right) \mathbf{y}.\]
 

As an interesting reminder, if \( \mathbf{A}\left( t\right)  \) commutes
with \( \int _{0}^{t}\mathbf{A}\left( \tau \right) \, d\tau  \) under
matrix multiplication, then this linear differential equation has
exact solution using the matrix exponential: \[
\mathbf{y}\left( t\right) =\exp \left( \int _{0}^{t}\mathbf{A}\left( \tau \right) d\tau \right) \mathbf{y}\left( 0\right) ,\]
 However, in this case, \( \mathbf{A}\left( t\right)  \) and its
integral do not commute.

There are many optional inputs and outputs available when using odeint
which can help tune the solver. These additional inputs and outputs
are not needed much of the time, however, and the three required input
arguments and the output solution suffice. The required inputs are
the function defining the derivative, the initial output vector, and
the time points to obtain a solution (with the initial value point
as the first element of this sequence). The output to \textbf{odeint}
is a matrix where each row contains the solution vector at each requested
time point (thus, the initial conditions are given in the first output
row). 

The following example illustrates the use of odeint including the
usage of the \textbf{Dfun} option which allows the user to specify
a gradient (with respect to \( \mathbf{y} \)) of the function, \textbf{\( \mathbf{f}\left( \mathbf{y},t\right)  \).}

\verbatiminput{example4.6}


\subsection{Gaussian quadrature (scipy.integrate.gauss\_quadtol)}

A few functions are also provided in order to perform simple Gaussian
quadrature over a fixed interval. The first is \textbf{gauss\_quad}
which performs fixed-order Gaussian quadrature. The second function
is \textbf{gauss\_quadtol} which performs Gaussian quadrature of multiple
orders until the difference in the integral estimate is beneath some
tolerance supplied by the user. These functions both use the module
\textbf{scipy.integrate.orthogonal} which can calculate the roots
and quadrature weights of a large variety of orthogonal polynomials.


\section{Optimization (scipy.optimize)}

There are several classical optimization algorithms provided by SciPy
in the \textbf{scipy.optimize} package. An overview of the module
is available using \textbf{scipy.help} (or pydoc.help):

\verbatiminput{example5.1} The first four algorithms are minimization
algorithms (fmin: Nelder-Mead simplex, fminBFGS: BFGS, fminNCG: Newton
Conjugate Gradient, and leastsq: Levenburg-Marquardt) while the last
algorithm actually finds the roots of a general function of possibly
many variables. It is included in the optimization package because
at the (non-boundary) extreme points of a function, the gradient is
equal to zero.


\subsection{Nelder-Mead Simplex algorithm (scipy.optimize.fmin)}

The simplex algorithm is probably the simplest way to minimize a fairly
well-behaved function. The simplex algorithm requires only function
evaluations and is a good choice for simple minimization problems.
However, because it does not use any gradient evaluations, it may
take longer to find the minimum. To demonstrate the minimization function
consider the problem of minimizing the Rosenbrock function of \( N \)
variables:\[
f\left( \mathbf{x}\right) =\sum _{i=1}^{N}100\left( x_{i}-x^{2}_{i-1}\right) ^{2}^{2}+\left( 1-x_{i-1}\right) ^{2}.\]
 The minimum value of this function is 0 which is achieved when \( x_{i}=1. \)
This minimum can be found using the \textbf{fmin} routine as shown
in the example below:

\verbatiminput{example5.2}
\end{document}
