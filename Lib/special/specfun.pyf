!%f90 -*- f90 -*-
python module specfun ! in 
    interface  ! in :specfun
        ! cpdsa
        ! cfs
        subroutine lqmn(mm,m,n,x,qm,qd) ! in :specfun:specfun.f
            integer optional,check((shape(qm,0)-1)==mm),depend(qm) :: mm=(shape(qm,0)-1)
            integer :: m
            integer optional,check((shape(qm,1)-1)==n),depend(qm) :: n=(shape(qm,1)-1)
            double precision :: x
            double precision dimension(mm + 1,n + 1) :: qm
            double precision dimension(mm + 1,n + 1),depend(mm,n) :: qd
        end subroutine lqmn
        subroutine clpmn(mm,m,n,x,y,cpm,cpd) ! in :specfun:specfun.f
            integer optional,check((shape(cpm,0)-1)==mm),depend(cpm) :: mm=(shape(cpm,0)-1)
            integer :: m
            integer optional,check((shape(cpm,1)-1)==n),depend(cpm) :: n=(shape(cpm,1)-1)
            double precision :: x
            double precision :: y
            complex*16 dimension(mm + 1,n + 1) :: cpm
            complex*16 dimension(mm + 1,n + 1),depend(mm,n) :: cpd
        end subroutine clpmn
        ! vvsa

        subroutine jdzo(nt,n,m,pcode,zo) ! in :specfun:specfun.f
            integer intent(in), check(nt<1400) :: nt
            integer depend(nt), intent(out), dimension(nt) :: n
            integer depend(nt), intent(out), dimension(nt) :: m
            integer depend(nt), intent(out), dimension(nt,4) :: pcode
            double precision intent(out), depend(nt), dimension(nt+1) :: zo
        end subroutine jdzo

        ! cbk
        ! cjy01
        ! rmn2sp
        subroutine bernob(n,bn) ! in :specfun:specfun.f
            integer optional,check((len(bn)-1)>=n),depend(bn) :: n=(len(bn)-1)
            double precision dimension(n + 1) :: bn
        end subroutine bernob
        subroutine bernoa(n,bn) ! in :specfun:specfun.f
            integer optional,check((len(bn)-1)>=n),depend(bn) :: n=(len(bn)-1)
            double precision dimension(n + 1) :: bn
        end subroutine bernoa
        ! qstar
        ! cv0
        ! cvqm
        ! cvql
        subroutine csphjy(n,z,nm,csj,cdj,csy,cdy) ! in :specfun:specfun.f
            integer optional,check((len(csj)-1)>=n),depend(csj) :: n=(len(csj)-1)
            complex*16 :: z
            integer :: nm
            complex*16 dimension(n + 1) :: csj
            complex*16 dimension(n + 1),depend(n) :: cdj
            complex*16 dimension(n + 1),depend(n) :: csy
            complex*16 dimension(n + 1),depend(n) :: cdy
        end subroutine csphjy

        ! ittjyb

        ! ittjya

        ! msta1
        ! msta2 

        ! cjylv
        ! rmn2l
        ! psi (psi_spec)
        subroutine cva2(kd,m,q,a) ! in :specfun:specfun.f
            integer :: kd
            integer :: m
            double precision :: q
            double precision :: a
        end subroutine cva2
        subroutine lpmns(m,n,x,pm,pd) ! in :specfun:specfun.f
            integer :: m
            integer optional,check((len(pm)-1)>=n),depend(pm) :: n=(len(pm)-1)
            double precision :: x
            double precision dimension(n + 1) :: pm
            double precision dimension(n + 1),depend(n) :: pd
        end subroutine lpmns
        ! rswfp
        subroutine jyndd(n,x,bjn,djn,fjn,byn,dyn,fyn) ! in :specfun:specfun.f
            integer :: n
            double precision :: x
            double precision :: bjn
            double precision :: djn
            double precision :: fjn
            double precision :: byn
            double precision :: dyn
            double precision :: fyn
        end subroutine jyndd
        subroutine gam0(x,ga) ! in :specfun:specfun.f
            double precision :: x
            double precision :: ga
        end subroutine gam0
        ! cisib
        subroutine eulera(n,en) ! in :specfun:specfun.f
            integer optional,check((len(en)-1)>=n),depend(en) :: n=(len(en)-1)
            double precision dimension(n + 1) :: en
        end subroutine eulera
        ! refine
        ! cisia

        ! itsl0
        ! stvl0
        ! stvl1

        subroutine clqn(n,x,y,cqn,cqd) ! in :specfun:specfun.f
            integer optional,check((len(cqn)-1)>=n),depend(cqn) :: n=(len(cqn)-1)
            double precision :: x
            double precision :: y
            complex*16 dimension(n + 1) :: cqn
            complex*16 dimension(n + 1),depend(n) :: cqd
        end subroutine clqn

        ! stvl0

        subroutine airyzo(nt,kf,xa,xb,xc,xd) ! in :specfun:specfun.f
            integer optional,check(len(xa)>=nt),depend(xa) :: nt=len(xa)
            integer :: kf
            double precision dimension(nt) :: xa
            double precision dimension(nt),depend(nt) :: xb
            double precision dimension(nt),depend(nt) :: xc
            double precision dimension(nt),depend(nt) :: xd
        end subroutine airyzo
        ! error
        ! cerror

        subroutine eulerb(n,en) ! in :specfun:specfun.f
            integer optional,check((len(en)-1)>=n),depend(en) :: n=(len(en)-1)
            double precision dimension(n + 1) :: en
        end subroutine eulerb
        subroutine cva1(kd,m,q,cv) ! in :specfun:specfun.f
            integer :: kd
            integer :: m
            double precision :: q
            double precision dimension(200) :: cv
        end subroutine cva1
        ! ittikb
        subroutine lqnb(n,x,qn,qd) ! in :specfun:specfun.f
            integer optional,check((len(qn)-1)>=n),depend(qn) :: n=(len(qn)-1)
            double precision :: x
            double precision dimension(n + 1) :: qn
            double precision dimension(n + 1),depend(n) :: qd
        end subroutine lqnb
        ! cjk

        ! ittika

        subroutine lamv(v,x,vm,vl,dl) ! in :specfun:specfun.f
            double precision intent(in) :: v
            double precision intent(in) :: x
            double precision intent(out) :: vm
            double precision intent(out), depend(v), dimension((int)floor(v)) :: vl
            double precision intent(out), depend(v), dimension((int)floor(v)) :: dl
        end subroutine lamv
        ! chguit
        ! kmn
        subroutine lagzo(n,x,w) ! in :specfun:specfun.f
            integer optional,check(len(x)>=n),depend(x) :: n=len(x)
            double precision dimension(n) :: x
            double precision dimension(n),depend(n) :: w
        end subroutine lagzo
        ! vvla

        ! cjyva
        ! cjyvb

        ! jy01a
        ! incog

        ! itika
        ! itikb

        ! jyv
        ! jynb
        ! stvh1

        subroutine legzo(n,x,w) ! in :specfun:specfun.f
            integer optional,check(len(x)>=n),depend(x) :: n=len(x)
            double precision dimension(n) :: x
            double precision dimension(n),depend(n) :: w
        end subroutine legzo
        ! aswfa
        ! jyna

        subroutine pbdv(v,x,dv,dp,pdf,pdd) ! in :specfun:specfun.f
            double precision intent(in) :: v
            double precision intent(in) :: x
            double precision intent(out),depend(v),dimension(abs( (int )v)) :: dv
            double precision intent(out),depend(v),dimension(abs( (int )v)) :: dp
            double precision intent(out) :: pdf
            double precision intent(out) :: pdd
        end subroutine pbdv

        ! itsh0

        subroutine cerzo(nt,zo) ! in :specfun:specfun.f
            integer optional,check(len(zo)>=nt),depend(zo) :: nt=len(zo)
            complex*16 dimension(nt) :: zo
        end subroutine cerzo

        ! gamma2

        ! chgu
        subroutine lamn(n,x,nm,bl,dl) ! in :specfun:specfun.f
            integer optional,check((len(bl)-1)>=n),depend(bl) :: n=(len(bl)-1)
            double precision :: x
            integer :: nm
            double precision dimension(n + 1) :: bl
            double precision dimension(n + 1),depend(n) :: dl
        end subroutine lamn
        ! comelp
        ! incob
        !subroutine cvf(kd,m,q,a,mj,f) ! in :specfun:specfun.f
        !    integer :: kd
        !    integer :: m
        !    double precision :: q
        !    double precision :: a
        !    integer :: mj
        !    double precision :: f
        !end subroutine cvf
        subroutine clpn(n,x,y,cpn,cpd) ! in :specfun:specfun.f
            integer optional,check((len(cpn)-1)>=n),depend(cpn) :: n=(len(cpn)-1)
            double precision :: x
            double precision :: y
            complex*16 dimension(n + 1) :: cpn
            complex*16 dimension(n + 1),depend(n) :: cpd
        end subroutine clpn
        subroutine lqmns(m,n,x,qm,qd) ! in :specfun:specfun.f
            integer :: m
            integer optional,check((len(qm)-1)>=n),depend(qm) :: n=(len(qm)-1)
            double precision :: x
            double precision dimension(n + 1) :: qm
            double precision dimension(n + 1),depend(n) :: qd
        end subroutine lqmns
        ! ciklv
        ! elit
        ! elit3

        ! eix
        ! e1xb

        ! chgm

        ! stvh0

        ! hygfx
        ! cchg
        ! hygfz
        ! itairy
        ! airya
        ! airyb

        ! ikna
        ! cjyna
        ! cjynb
        ! iknb
        subroutine lpmn(mm,m,n,x,pm,pd) ! in :specfun:specfun.f
            integer optional,check((shape(pm,0)-1)==mm),depend(pm) :: mm=(shape(pm,0)-1)
            integer :: m
            integer optional,check((shape(pm,1)-1)==n),depend(pm) :: n=(shape(pm,1)-1)
            double precision :: x
            double precision dimension(mm + 1,n + 1) :: pm
            double precision dimension(mm + 1,n + 1),depend(mm,n) :: pd
        end subroutine lpmn
        ! mtu0
        ! cy01
        ! ffk
        ! scka
        ! sckb
        ! cpdla
        subroutine fcszo(kf,nt,zo) ! in :specfun:specfun.f
            integer :: kf
            integer optional,check(len(zo)>=nt),depend(zo) :: nt=len(zo)
            complex*16 dimension(nt) :: zo
        end subroutine fcszo
        ! e1xa
        ! lpmv

        ! cgama

        subroutine aswfb(m,n,c,x,kd,cv,s1f,s1d) ! in :specfun:specfun.f
            integer :: m
            integer :: n
            double precision :: c
            double precision :: x
            integer :: kd
            double precision :: cv
            double precision :: s1f
            double precision :: s1d
        end subroutine aswfb

        ! chgu

        ! itth0

        ! lgama

        subroutine lqna(n,x,qn,qd) ! in :specfun:specfun.f
            integer optional,check((len(qn)-1)>=n),depend(qn) :: n=(len(qn)-1)
            double precision :: x
            double precision dimension(n + 1) :: qn
            double precision dimension(n + 1),depend(n) :: qd
        end subroutine lqna
        ! dvla
        ! ik01a
        subroutine cpbdn(n,z,cpb,cpd) ! in :specfun:specfun.f
            integer intent(in) :: n
            complex*16 intent(in) :: z
            complex*16 depend(n), intent(out), dimension(abs(n)) :: cpb
            complex*16 depend(n), intent(out), dimension(abs(n)) :: cpd
        end subroutine cpbdn
        ! ik01b
        ! beta
        subroutine lpn(n,x,pn,pd) ! in :specfun:specfun.f
            integer optional,check((len(pn)-1)>=n),depend(pn) :: n=(len(pn)-1)
            double precision :: x
            double precision dimension(n + 1) :: pn
            double precision dimension(n + 1),depend(n) :: pd
        end subroutine lpn
        subroutine fcoef(kd,m,q,a,fc) ! in :specfun:specfun.f
            integer :: kd
            integer :: m
            double precision :: q
            double precision :: a
            double precision dimension(251) :: fc
        end subroutine fcoef
        subroutine sphi(n,x,nm,si,di) ! in :specfun:specfun.f
            integer optional,check((len(si)-1)>=n),depend(si) :: n=(len(si)-1)
            double precision :: x
            integer :: nm
            double precision dimension(n + 1) :: si
            double precision dimension(n + 1),depend(n) :: di
        end subroutine sphi
        ! pbwa
        ! rmn1
        ! dvsa
        
        ! e1z
        
        ! itjyb
        ! chgul
        ! gmn
        ! itjya
        ! stvlv

        subroutine rcty(n,x,nm,ry,dy) ! in :specfun:specfun.f
            integer optional,check((len(ry)-1)>=n),depend(ry) :: n=(len(ry)-1)
            double precision :: x
            integer :: nm
            double precision dimension(n + 1) :: ry
            double precision dimension(n + 1),depend(n) :: dy
        end subroutine rcty
        subroutine lpni(n,x,pn,pd,pl) ! in :specfun:specfun.f
            integer optional,check((len(pn)-1)>=n),depend(pn) :: n=(len(pn)-1)
            double precision :: x
            double precision dimension(n + 1) :: pn
            double precision dimension(n + 1),depend(n) :: pd
            double precision dimension(n + 1),depend(n) :: pl
        end subroutine lpni

        ! klvna

        ! chgubi
        subroutine cyzo(nt,kf,kc,zo,zv) ! in :specfun:specfun.f
            integer optional,check(len(zo)>=nt),depend(zo) :: nt=len(zo)
            integer :: kf
            integer :: kc
            complex*16 dimension(nt) :: zo
            complex*16 dimension(nt),depend(nt) :: zv
        end subroutine cyzo
        ! klvnb
        ! rmn2so
        subroutine csphik(n,z,nm,csi,cdi,csk,cdk) ! in :specfun:specfun.f
            integer optional,check((len(csi)-1)>=n),depend(csi) :: n=(len(csi)-1)
            complex*16 :: z
            integer :: nm
            complex*16 dimension(n + 1) :: csi
            complex*16 dimension(n + 1),depend(n) :: cdi
            complex*16 dimension(n + 1),depend(n) :: csk
            complex*16 dimension(n + 1),depend(n) :: cdk
        end subroutine csphik
        subroutine bjndd(n,x,bj,dj,fj) ! in :specfun:specfun.f
            integer :: n
            double precision :: x
            double precision dimension(101) :: bj
            double precision dimension(101) :: dj
            double precision dimension(101) :: fj
        end subroutine bjndd
        subroutine sphj(n,x,nm,sj,dj) ! in :specfun:specfun.f
            integer optional,check((len(sj)-1)>=n),depend(sj) :: n=(len(sj)-1)
            double precision :: x
            integer :: nm
            double precision dimension(n + 1) :: sj
            double precision dimension(n + 1),depend(n) :: dj
        end subroutine sphj
        subroutine othpl(kf,n,x,pl,dpl) ! in :specfun:specfun.f
            integer :: kf
            integer optional,check((len(pl)-1)>=n),depend(pl) :: n=(len(pl)-1)
            double precision :: x
            double precision dimension(n + 1) :: pl
            double precision dimension(n + 1),depend(n) :: dpl
        end subroutine othpl
        subroutine klvnzo(nt,kd,zo) ! in :specfun:specfun.f
            integer intent(in), check(nt>0) :: nt
            integer intent(in), check(kd>=1 || kd<=8) :: kd
            double precision intent(out), depend(nt), dimension(nt) :: zo
        end subroutine klvnzo
        ! rswfo
        ! ch12n
        subroutine jyzo(n,nt,rj0,rj1,ry0,ry1) ! in :specfun:specfun.f
            integer :: n
            integer optional,check(len(rj0)>=nt),depend(rj0) :: nt=len(rj0)
            double precision dimension(nt) :: rj0
            double precision dimension(nt),depend(nt) :: rj1
            double precision dimension(nt),depend(nt) :: ry0
            double precision dimension(nt),depend(nt) :: ry1
        end subroutine jyzo

        ! ikv 

        ! sdmn
        ! ajyik
        ! cikvb

        ! cikva
        ! cfc

        ! fcs
        subroutine rctj(n,x,nm,rj,dj) ! in :specfun:specfun.f
            integer optional,check((len(rj)-1)>=n),depend(rj) :: n=(len(rj)-1)
            double precision :: x
            integer :: nm
            double precision dimension(n + 1) :: rj
            double precision dimension(n + 1),depend(n) :: dj
        end subroutine rctj
        subroutine herzo(n,x,w) ! in :specfun:specfun.f
            integer optional,check(len(x)>=n),depend(x) :: n=len(x)
            double precision dimension(n) :: x
            double precision dimension(n),depend(n) :: w
        end subroutine herzo
        ! jy01b
        ! enxb
        subroutine sphk(n,x,nm,sk,dk) ! in :specfun:specfun.f
            integer optional,check((len(sk)-1)>=n),depend(sk) :: n=(len(sk)-1)
            double precision :: x
            integer :: nm
            double precision dimension(n + 1) :: sk
            double precision dimension(n + 1),depend(n) :: dk
        end subroutine sphk
        ! enxa
        ! gaih
        subroutine pbvv(v,x,vv,vp,pvf,pvd) ! in :specfun:specfun.f
            double precision intent(in) :: v
            double precision intent(in) :: x
            double precision intent(out),depend(v),dimension((int )v) :: vv
            double precision intent(out),depend(v),dimension((int )v) :: vp
            double precision intent(out) :: pvf
            double precision intent(out) :: pvd
        end subroutine pbvv
        subroutine clqmn(mm,m,n,x,y,cqm,cqd) ! in :specfun:specfun.f
            integer optional,check((shape(cqm,0)-1)==mm),depend(cqm) :: mm=(shape(cqm,0)-1)
            integer :: m
            integer optional,check((shape(cqm,1)-1)==n),depend(cqm) :: n=(shape(cqm,1)-1)
            double precision :: x
            double precision :: y
            complex*16 dimension(mm + 1,n + 1) :: cqm
            complex*16 dimension(mm + 1,n + 1),depend(mm,n) :: cqd
        end subroutine clqmn
        subroutine segv(m,n,c,kd,cv,eg) ! in :specfun:specfun.f
            integer :: m
            integer :: n
            double precision :: c
            integer :: kd
            double precision :: cv
            double precision dimension(200) :: eg
        end subroutine segv
        ! ciknb
        ! cikna
        ! mtu12
        ! cik01
        
        ! cpsi
        
        subroutine sphy(n,x,nm,sy,dy) ! in :specfun:specfun.f
            integer optional,check((len(sy)-1)>=n),depend(sy) :: n=(len(sy)-1)
            double precision :: x
            integer :: nm
            double precision dimension(n + 1) :: sy
            double precision dimension(n + 1),depend(n) :: dy
        end subroutine sphy
        ! jelp
        
        ! stvhv
    end interface 
end python module specfun

! This file was auto-generated with f2py (version:2.13.175-1239).
! See http://cens.ioc.ee/projects/f2py2e/
