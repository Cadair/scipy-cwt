!    -*- f90 -*-
! Author: Pearu Peterson <pearu@cens.ioc.ee>
!
python module dfitpack ! in

  usercode '''

static double dmax(double* seq,int len) {
  double val;
  int i;
  if (len<1)
    return -1e308;
  val = seq[0];
  for(i=1;i<len;++i)
    if (seq[i]>val) val = seq[i];
  return val;
}
static double dmin(double* seq,int len) {
  double val;
  int i;
  if (len<1)
    return 1e308;
  val = seq[0];
  for(i=1;i<len;++i)
    if (seq[i]<val) val = seq[i];
  return val;
}
static double calc_b(double* x,int m,double* tx,int nx) {
  double val1 = dmin(x,m);
  double val2 = dmin(tx,nx);
  if (val2>val1) return val1;
  val1 = dmax(tx,nx);
  return val2 - (val1-val2)/nx;
}
static double calc_e(double* x,int m,double* tx,int nx) {
  double val1 = dmax(x,m);
  double val2 = dmax(tx,nx);
  if (val2<val1) return val1;
  val1 = dmin(tx,nx);
  return val2 + (val2-val1)/nx;
}
static int imax(int i1,int i2) {
  return MAX(i1,i2);
}
  '''

  interface  ! in :dfitpack

     subroutine surfit_smth(iopt,m,x,y,z,w,xb,xe,yb,ye,kx,ky,s,nxest,nyest,&
          nmax,eps,nx,tx,ny,ty,c,fp,wrk1,lwrk1,wrk2,lwrk2,&
          iwrk,kwrk,ier)
       !  nx,tx,ny,ty,c,fp,ier = surfit_smth(x,y,z,[w,xb,xe,yb,ye,kx,ky,s,eps,lwrk2])

       usercode '''
       static int calc_lwrk1(void) {
         int u = nxest-kx-1;
         int v = nyest-ky-1;
         int km = MAX(kx,ky)+1;
         int ne = MAX(nxest,nyest);
         int bx = kx*v+ky+1;
         int by = ky*u+kx+1;
         int b1,b2;
         if (bx<=by) {b1=bx;b2=bx+v-ky;}
         else {b1=by;b2=by+u-kx;}
         return u*v*(2+b1+b2)+2*(u+v+km*(m+ne)+ne-kx-ky)+b2+1;
       }
       static int calc_lwrk2(void) {
         int u = nxest-kx-1;
         int v = nyest-ky-1;
         int bx = kx*v+ky+1;
         int by = ky*u+kx+1;
         int b2 = (bx<=by?bx+v-ky:by+u-kx);
         return u*v*(b2+1)+b2;
       }
       '''

       fortranname surfit
       
       integer intent(hide) :: iopt=0
       integer intent(hide),depend(x,kx,ky),check(m>=(kx+1)*(ky+1)) &
            :: m=len(x)
       real*8 dimension(m) :: x
       real*8 dimension(m),depend(m),check(len(y)==m) :: y
       real*8 dimension(m),depend(m),check(len(y)==m) :: z
       real*8 optional,dimension(m),depend(m),check(len(w)==m) :: w = 1.0
       real*8 optional,depend(x,m) :: xb=dmin(x,m)
       real*8 optional,depend(x,m) :: xe=dmax(x,m)
       real*8 optional,depend(y,m) :: yb=dmin(y,m)
       real*8 optional,depend(y,m) :: ye=dmax(y,m)
       integer check(1<=kx && kx<=5) :: kx = 3
       integer check(1<=ky && ky<=5) :: ky = 3
       real*8 optional,check(0.0<=s) :: s = m
       integer optional,depend(kx,m),check(nxest>=2*(kx+1)) &
            :: nxest = imax(kx+1+sqrt(m/2),2*(kx+1))
       integer optional,depend(ky,m),check(nyest>=2*(ky+1)) &
            :: nyest = imax(ky+1+sqrt(m/2),2*(ky+1))
       integer intent(hide),depend(nxest,nyest) :: nmax=MAX(nxest,nyest)
       real*8 optional,check(0.0<eps && eps<1.0) :: eps = 1e-16
       integer intent(out) :: nx
       real*8 dimension(nmax),intent(out),depend(nmax) :: tx
       integer intent(out) :: ny
       real*8 dimension(nmax),intent(out),depend(nmax) :: ty
       real*8 dimension((nxest-kx-1)*(nyest-ky-1)), &
            depend(kx,ky,nxest,nyest),intent(out) :: c
       real*8 intent(out) :: fp
       real*8 dimension(lwrk1),intent(cache,out),depend(lwrk1) :: wrk1
       integer intent(hide),depend(m,kx,ky,nxest,nyest) :: lwrk1=calc_lwrk1()
       real*8 dimension(lwrk2),intent(cache,hide),depend(lwrk2) :: wrk2
       integer optional,intent(in),depend(kx,ky,nxest,nyest) :: lwrk2=calc_lwrk2()
       integer dimension(kwrk),depend(kwrk),intent(cache,hide) :: iwrk
       integer intent(hide),depend(m,nxest,nyest,kx,ky) &
            :: kwrk=m+(nxest-2*kx-1)*(nyest-2*ky-1)
       integer intent(out) :: ier
     end subroutine surfit_smth

     subroutine surfit_lsq(iopt,m,x,y,z,w,xb,xe,yb,ye,kx,ky,s,nxest,nyest,&
          nmax,eps,nx,tx,ny,ty,c,fp,wrk1,lwrk1,wrk2,lwrk2,&
          iwrk,kwrk,ier)
       ! tx,ty,c,fp,ier = surfit_lsq(x,y,z,tx,ty,[w,xb,xe,yb,ye,kx,ky,eps,lwrk2])

       usercode '''
       static int calc_lwrk1(void) {
         int u = nxest-kx-1;
         int v = nyest-ky-1;
         int km = MAX(kx,ky)+1;
         int ne = MAX(nxest,nyest);
         int bx = kx*v+ky+1;
         int by = ky*u+kx+1;
         int b1,b2;
         if (bx<=by) {b1=bx;b2=bx+v-ky;}
         else {b1=by;b2=by+u-kx;}
         return u*v*(2+b1+b2)+2*(u+v+km*(m+ne)+ne-kx-ky)+b2+1;
       }
       static int calc_lwrk2(void) {
         int u = nxest-kx-1;
         int v = nyest-ky-1;
         int bx = kx*v+ky+1;
         int by = ky*u+kx+1;
         int b2 = (bx<=by?bx+v-ky:by+u-kx);
         return u*v*(b2+1)+b2;
       }
       '''

       fortranname surfit
       
       integer intent(hide) :: iopt=-1
       integer intent(hide),depend(x,kx,ky),check(m>=(kx+1)*(ky+1)) &
            :: m=len(x)
       real*8 dimension(m) :: x
       real*8 dimension(m),depend(m),check(len(y)==m) :: y
       real*8 dimension(m),depend(m),check(len(y)==m) :: z
       real*8 optional,dimension(m),depend(m),check(len(w)==m) :: w = 1.0
       real*8 optional,depend(x,tx,m,nx) :: xb=calc_b(x,m,tx,nx)
       real*8 optional,depend(x,tx,m,nx) :: xe=calc_e(x,m,tx,nx)
       real*8 optional,depend(y,ty,m,ny) :: yb=calc_b(y,m,ty,ny)
       real*8 optional,depend(y,ty,m,ny) :: ye=calc_e(y,m,ty,ny)
       integer check(1<=kx && kx<=5) :: kx = 3
       integer check(1<=ky && ky<=5) :: ky = 3
       real*8 intent(hide) :: s = 0.0
       integer intent(hide),depend(nx) :: nxest = nx
       integer intent(hide),depend(ny) :: nyest = ny
       integer intent(hide),depend(nx,ny) :: nmax=MAX(nx,ny)
       real*8 optional,check(0.0<eps && eps<1.0) :: eps = 1e-16
       integer intent(hide),depend(tx,kx),check(2*kx+2<=nx) :: nx = len(tx)
       real*8 dimension(nx),intent(in,out,overwrite) :: tx
       integer intent(hide),depend(ty,ky),check(2*ky+2<=ny) :: ny = len(ty)
       real*8 dimension(ny),intent(in,out,overwrite) :: ty
       real*8 dimension((nx-kx-1)*(ny-ky-1)),depend(kx,ky,nx,ny),intent(out) :: c
       real*8 intent(out) :: fp
       real*8 dimension(lwrk1),intent(cache,hide),depend(lwrk1) :: wrk1
       integer intent(hide),depend(m,kx,ky,nxest,nyest) :: lwrk1=calc_lwrk1()
       real*8 dimension(lwrk2),intent(cache,hide),depend(lwrk2) :: wrk2
       integer optional,intent(in),depend(kx,ky,nxest,nyest) :: lwrk2=calc_lwrk2()
       integer dimension(kwrk),depend(kwrk),intent(cache,hide) :: iwrk
       integer intent(hide),depend(m,nx,ny,kx,ky) &
            :: kwrk=m+(nx-2*kx-1)*(ny-2*ky-1)
       integer intent(out) :: ier
     end subroutine surfit_lsq

  end interface
end python module dfitpack

! This file was auto-generated with f2py (version:2.35.229-1475).
! See http://cens.ioc.ee/projects/f2py2e/
