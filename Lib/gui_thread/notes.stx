<H1> 'gui_thread' Home Page</H1> 

Overview

  The 'gui_thread' package runs wxPython in a second thread leaving, 
  the Python command line interpreter running in the primary thread.  
  It allows users to create and interact with any type of wxPython 
  window from the Python command line.  

  It is designed to work on Windows, Linux, and hopefully other 
  platforms.

Status

  We'll call it alpha. See the "Todo" section for more details.

Download

  The code is available in the following formats.

  o "compressd tar ball":gui_thread.tgz/download

  o "windows zip":gui_thread.zip/download

  To install, unpack the archive somewhere in your python path.
  Then, fire up Python2.x and type::

     >>> import gui_thread
 
  It may also work with Python1.5.2, but it hasn't been recently
  tested.  See the example section for usage information.

  gui_thread will work with PythonWin and command line Python 
  interpreters on Windows and Linux.  It does not work with IDLE
  or other TkInter applications because wxPython and TkInter do
  not play nicely with one another - even if they live in different
  threads.

Requirements

  The wxPython package.  I use 2.2.5, but it may work with earlier 
  versions.

Bug Reports

  Send them to "eric jones", mailto:ej@ee.duke.edu

Example Code

  Here is a a simple example included in the package::
 	
        >>> import gui_thread 
	<wait for several seconds while wxPython starts up>
	wxPython imported 
	>>> from gui_thread.examples import SimpleFrame 
	>>> proxy_class = gui_thread.register(SimpleFrame)
	>>> window = proxy_class() 
	>>> window.Show(1) 
	1 
	>>> window.SetTitle('bob') 
	>>> window.GetTitle()
	'bob'
	>>> window.GetPosition()
	(38, 430)
	>>> window.SetPosition((0,0)) 
	>>> window.Blue() #change the color of a window button to blue 
	>>> window.Red() #now to red

Background

  As you may be aware, wxWindows is not thread-safe, and all GUI 
  objects must live in a single thread.  Further, any interaction with 
  those windows must occur from within that same thread.  It is 
  possible to get around this limitation by sending events from non-
  GUI threads to a helper function in the GUI thread requesting some 
  GUI action be carried out.  The gui_thread package handles this 
  automatically by creating "proxy" classes that wrap each of the 
  actual wxPython class methods with helper methods.  These helpers 
  send events to the GUI thread requesting the appropriate action be 
  taken instead of attempting to call window methods directly.  The 
  process is nearly transparent, only requiring users to register GUI 
  classes with gui_thread::

	>>> proxy = gui_thread.register(some_wxPython_derived_window_class) 

  The registration process checks to see if wxPython is running in the 
  main thread or not.  If it is, it simply returns the original class 
  unchanged.  Only when wxPython is living in the secondary thread 
  does register wrap the orignial with a proxy class.
 
Purpose

  'gui_thread' was originally developed to allow data plots and the 
  command line interpreter to exist at the same time without blocking 
  users from interacting with either of them.  For example::

	>>> import scipy.plt as plt
	# plot x vs y 
	>>> plt.plot([1,2,3],[1,4,9])
	# plot another line on the same graph 
	>>> plt.hold('on')	
	>>> plt.plot([1,2,3],[1,8,27])
	# create a 2nd plot window and fill it with a plot 
	>>> plt.figure()
	>>> plt.plot([1,2,3],[1,8,27])

  This capability is similar to how Matlab Its use has since expanded 
  to popping up data viewers for other types, and I expect it is 
  useful in other areas.

Todo

  o Windows

    Currently, gui_thread seems to work fairly well on Windows 2000 
    with Python 2.0/wxPython2.2.5.  It was also used succesfully with 
    1.5.2 for a long period.  Since then, some changes have been made, 
    and it hasn't been tested against 1.5.2, so your milage may vary.  
    My hunch is it still works.

    I have had random crashes when using it within an interpreter 
    session that has been open for several days and had hundreds of 
    GUI windows created and destroyed.  I haven't tracked down this 
    issue yet to see if it has to do with 'gui_thread' or some other 
    extension modules I use.

  o Linux 

    Recent changes have gotten Linux support at least up and running.  
    The plotting package (not yet released), which works with Windows,
    does not seem to work on Linux. I'm not sure if this is a problem 
    with the plotting package or 'gui_thread'.

    Also, when shutting down, it Python often hangs.  I have a feeling 
    this has to do with a call to app.ExitMainLoop() not working as
    I had hoped.  

  o General

    o  Exception reporting is not as informative as I'd like it to be.  
       Right now, the exception is reported, but its location is not.
    
    o  Newly created windows down gain the focus on MSWindows machines.
       I wish they did.

    o  Ctrl-D in command line Python on Windows shuts down just fine, 
       but gives a KeyboardInterrupt (I think) error in the exit function.
       It doesn't appear to do any harm, it just isn't pretty.

    o  On Windows 98, there is a shutdown bug and gui_thread hangs when
       windows are open.  Close all windows will let Python close.

     

Major Issues

  The biggest outstanding problem with 'gui_thread' has to do with 
  quirks with wxPython and how Python imports modules.  For gui_thread 
  to work, the FIRST time the wxPython module is imported must occur 
  in the second thread.  This means its always a good idea to make 
  'import gui_thread' the first thing you type at the command line, or 
  put it in your start-up script.  Importing wxPython takes several 
  seconds, so a lot can happen in that time.  If you execute a script 
  that tries load another wxPython dependent module in the main 
  thread, it could happen before the 2nd thread gets wxPython imported 
  and gui_thread will then not work.

  The nicest way to fix this is for 'gui_thread.start()' to wait for a 
  signal from the second thread indicating that it is finished 
  starting up wxPython.  This works great in non-interactive mode.  
  However, Python has a module lock that only allows one module to be 
  imported at a time.  Because of how this lock works, dead-lock will 
  occur when attempting this approach in the interactive interpreter.  
  A sub-directory of gui_thread called thread_tests has a script that 
  demonstrates the problem along,a "discussion thread":import_thread_lock
  that discussed the problem on the Thread-SIG, and some cod to patch 
  into 'import.c' of Python to solve the problem.  The patch code isn't 
  extremely well tested (not at all with Python 2.x, so use at your own 
  risk.

Techinical Overview

  In order to use the standard command line interpreter along with a 
  GUI, wxPython is run in a second thread.  The standard interpreter 
  continues to run in the first thread where you can interact with it 
  in the normal way.  The two threads are called the wxPython thread 
  and the main thread in the remainder of the discussion.

  wxPython currently does not work well if interactions with windows 
  occur from multiple threads.  The first import of wxPython must 
  occur in the second thread.  Likewise, all creation of and 
  interaction with windows must occur form the second thread.  Methods 
  running in the first thread interact with windows by firing events 
  which are handled in the second thread.  It is a little unwieldy to 
  create events and handlers for all the windows you want to create, 
  so gui_thread manages this for you.  It creates a "proxy" class that 
  wraps all the methods of the original class.  The proxy handles all 
  the event firing and threading issues and hopefully behaves just 
  like the underlying window class.

  Be sure that gui_thread is the first module imported by your 
  application or at the command line to insure that  wxPython is 
  originally imported in the second thread. 

  If you are writing a wxPython app that will run in the first thread, 
  you can still use gui_thread.  It will sense that a wxApp is already 
  running, and register() will not wrap classes with a proxy.  It 
  simply returns the  original class unaltered.       

  Architecture  

    There are three major issues to handle: 

    o  Forcing the import of wxPython to occur in the second thread. 

    o  Designing a event/handler system that is transparent to the 
       user.  Events must send arbitrary calling arguments to window 
       methods in the second thread.  The return  values from the window 
       methods must be sent back to the proxy method that fired the 
       event. 

    o  Generating proxy wrappers for any arbitrary window class.  This 
       must handle wrapping methods from all base classes also.

    1. Import of wxPython

      This issue requires some cooperation from the user, i.e. they 
      must be sure 'gui_thread' is imported before any other module 
      that imports any part of wxPython.      

      This issue also neccessitated the division of gui_thread into 
      two pieces, gui_thread and gui_thread_guts.  gui_thread_guts 
      contains all classes that are derived from a wxPython class. 
      gui_thread starts a second thread and then import 
      gui_thread_guts from within the second thread.  I think there 
      may actually be a way to hide the classes of gui_thread_guts 
      inside a function within gui_thread so that the import of 
      wxPython is not at the top level of the module(where it would be 
      imported into the  first thread!), but the coding wasn't as 
      nice, so I didn't put much effort into it.  If you have a 
      suggestion that doesn't hurt my brain, I may change it.  For 
      now, it'll keep a package structure.

    2. event/handler system

      Here's what happens when a proxy object method is called from 
      the main thread.  

         0.  (**Main thread**) Prepare to generate 'proxy_event'

         1.  (**Main thread**) The proxy method creates a 
            'proxy_event' and packs it with information about the 
            unbound method it wants called and the arguments to use.

         2.  (**Main thread**) It posts the event to the 
             'event_catcher' window in the wxPython thread and then 
             blocks the thread waiting for the signal that the event 
             was handled.

         3.  (**wxPython thread**) 'event_catcher' receives and 
             handles the 'proxy_event' with 'proxy_handler()'.  
             'proxy_handler()', unpacks the method and arguments and
             makes the call.

         4.  (**wxPython thread**) It then signals that the call was 
             made and puts its return value in a place where the proxy 
             object can find it.

         5.  (**Main thread**) The proxy method receives the finished 
             signal, grabs the return value from the wxPython call 
             and returns it as its own.

         As an example, assume we have created a frame object from the 
         'frame_proxy' class (a wrapper around the actual 
         'SimpleFrame')::
                
                >>> frame.Show(1)
                
         The proxy class generated by 'register()' for Show looks 
         like::
   
           class frame_proxy(proxy_base):
                      .
                      .
                      .
               def Show(self,*args,**kw):
                   # 0. import items needed in call
                   from gui_thread_guts import proxy_event
                   from gui_thread.examples import SimpleFrame
                   # 0. Create a synchronization object for blocking
                   finished = threading.Event()
                   # 0. If any of the arguments are themselve 
                   # 0. proxies, strip the proxy so that the actual 
                   # 0. underlying object is used as the argument.
                   args = dereference_arglist(args)
                   # 0. wx_obj is the actual cone_viewer object that 
                   # 0. is wrapped by this method.  While we can't 
                   # 0. call it from this string, we can have a 
                   # 0. refernce to it. wx_obj is appended to the 
                   # 0. front of the argument list in the "self" 
                   location for unbound method calls.
                   arg_list = tuple([self.wx_obj] + list(args))
                   # 1. create a proxy event and pack it with all 
                   # 1. this info including the synchronization 
                   # 1. object.
                   evt = proxy_event(SimpleFrame.Show,arg_list,kw, \
                                     finished)
                   # 2. post the event to the "event_catcher" window 
                   # 2. in the wxPython thread, and wait for 
                   # 2. the signal that 
                   self.post(evt)                    
                   finished.wait()
                   # 5. When the proxy_handler() was done, it stored 
                   # 5. info about whether exceptions occured and the
                   # 5. return value in the synchronization object.
                   # 5. Pass on the excpetion or return the result.  
                   if finished.exception_info:
                       raise finished.exception_info[0], \
                             finished.exception_info[1]
                   return finished._result
                        
         The 'event_catcher' side looks like::
            
             class event_catcher(wxFrame):
                 def __init__(self):
                     wxFrame.__init__(self, NULL,-1,'')        
                     # 3.  The receive doesn't really happen here,
                     # 3.  but the followin line sets it up.
                     PROXY_EVENT(self,self.proxy_handler)    
                 def proxy_handler(self,evt): 
                     try:
                         # 3. Unpack the method and arguments from 
                         # 3. the event and execute them.  Set the 
                         # 3. result in the synchronization object 
                         (finished).
                         evt.finished._result = apply(evt.method, \
                                                evt.args,evt.kw)
                         evt.finished.exception_info = None
                         # 4. All went well. Signal the main thread
                         # 4. that we're finished.
                         evt.finished.set()
                     except:
                         # 4. or:
                         # 4. An exception occured. Print some info 
                         # 4. that is helpful for debugging, but the 
                         # 4. exception data in the synchronization 
                         # 4. object, and signal finished.
                         print 'exception occured in following call:'
                         print '\tmethod:', evt.method
                         print '\targuments:', evt.args
                         print '\tkey words:', evt.kw
                         import sys
                         evt.finished.exception_info = \
                                            sys.exc_info()[:2]
                         evt.finished.set()

         Notice that the thread synchronization object (finished) 
         serves two purposes.  First, it blocks the calling thread 
         until the proxy_handler() has executed.  Second, it is the 
         pipe through which the return value from the window operation 
         is sent back to the proxy method.
        
    3.  Generating proxy classes
            
        The 'register(wx_class_xxx)' method in 'gui_thread' checks 
        whether the 'wxApp' is running in the main thread.  if so, it 
        returns the 'wx_class' unaltered.  if not, 'proxify()' creates 
        a proxy class for 'wx_class_xxx'.  The objects generated from 
        the proxy class in the main thread are tied to a wx_class 
        object in the wxPython thread.  Calls to proxy object methods 
        are sent to the wx_class object for execution.  The proxy 
        object should behave exactly as if it were the 'wx_class' 
        object so that the programmer is not bothered with any event 
        or threading details.

        The current approach searches the 'wx_class' and all of its 
        base classes for unique method names.  It then generates a 
        method in the proxy class for each of these methods.  The 
        proxy method for 'foo()' has code identical to that of 
        'Show()' in the previous section with foo substituted in the 
        appropriate places.  for a typical 'wxFrame' object, 
        approximately 150 methods are generated.  An alternative would 
        be to actually create proxy classes for each of the base 
        classes so that the proxy class inheritance hierarchy mimics 
        that of the wx_class. This would allow re-use of methods, but 
        I saw no other benefit. if we were wrapping a million 
        different classes, this might be a better approach, but 
        wrapping less than 10 classes is probably more likely. if 
        there is a pressing reason to pursue the hierarchical 
        approach, such as optimization or memory concerns, let me know 
        and we can explore it.

        Proxify methods for '__init__()' methods are slightly different 
        than those of all other methods.  The main difference is that 
        the result of the 'proxy_handler()' calls becomes the 'wx_obj' 
        for the proxy object instead of the return value of the proxy 
        method.

        Currently, proxies are only generated for the methods.  I 
        think proxies could also be added for the attributes by 
        creating '__getattr__' and '__setattr__' methods.
